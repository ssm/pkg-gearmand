.TH "GEARMAN_WORKER_ADD_FUNCTION" "3" "March 14, 2012" "0.29" "Gearmand"
.SH NAME
gearman_worker_add_function \- Gearmand Documentation, http://gearman.info/
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructeredText.
.
.SH SYNOPSIS
.sp
#include <libgearman/gearman.h>
.INDENT 0.0
.TP
.B gearman_worker_st
.UNINDENT
.INDENT 0.0
.TP
.B int gearman_worker_timeout(gearman_worker_st *worker);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_worker_set_timeout(gearman_worker_st *worker, int timeout);
.UNINDENT
.INDENT 0.0
.TP
.B void *gearman_worker_context(const gearman_worker_st *worker);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_worker_set_context(gearman_worker_st *worker, void *context);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_worker_set_workload_malloc_fn(gearman_worker_st *worker, gearman_malloc_fn *function, void *context);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_worker_set_workload_free_fn(gearman_worker_st *worker, gearman_free_fn *function, void *context);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_worker_wait(gearman_worker_st *worker);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_worker_register(gearman_worker_st *worker, const char *function_name, uint32_t timeout);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_worker_unregister(gearman_worker_st *worker, const char *function_name);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_worker_unregister_all(gearman_worker_st *worker);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_job_st *gearman_worker_grab_job(gearman_worker_st *worker, gearman_job_st *job, gearman_return_t *ret_ptr);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_job_free_all(gearman_worker_st *worker);
.UNINDENT
.INDENT 0.0
.TP
.B bool gearman_worker_function_exist(gearman_worker_st *worker, const char *function_name, size_t function_length);
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_worker_work(gearman_worker_st *worker);
.UNINDENT
.sp
Link with \-lgearman
.SH DESCRIPTION
.sp
\fI\%gearman_worker_st\fP is used for worker communication with the server.
.sp
\fBgearman_worker_context()\fP and \fBgearman_worker_set_context()\fP can be used to store an arbitrary object for the user.
.sp
\fBgearman_worker_set_task_context_free_fn()\fP sets a trigger that will be called when a \fBgearman_task_st\fP is released.
.sp
\fBgearman_worker_timeout()\fP and \fBgearman_worker_set_timeout()\fP get and set the current timeout value, in milliseconds, for the worker.
.sp
\fBgearman_worker_function_exist()\fP is used to determine if a given worker has a specific function.
.sp
Normally \fImalloc(3)\fP and \fIfree(3)\fP are used for allocation and releasing workloads. \fBgearman_worker_set_workload_malloc_fn()\fP and \fBgearman_worker_set_workload_free_fn()\fP can be used to replace these with custom functions.
.sp
If you need to remove a function from the server you can call either \fBgearman_worker_unregister_all()\fP to remove all functions that the worker has told the \fBgearmand\fP server about, or you can use \fBgearman_worker_unregister()\fP to remove just a single function.
.SH RETURN
.sp
Various
.SH HOME
.sp
To find out more information please check:
\fI\%http://gearman.info/\fP
.SH SEE ALSO
.sp
\fIgearmand(8)\fP \fIlibgearman(3)\fP
.SH AUTHOR
Data Differential http://www.datadifferential.com/
.SH COPYRIGHT
2012, Data Differential, http://www.datadifferential.com/
.\" Generated by docutils manpage writer.
.\" 
.
